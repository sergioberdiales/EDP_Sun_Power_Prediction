[
["index.html", "EDP Sun Power prediction Challenge Introducción", " EDP Sun Power prediction Challenge Sergio Berdiales Introducción En este notebook estoy incluyendo el proceso de creación de los modelos con los que intentaré colarme en el ranking de participantes del Challenge de machine learning “Sun Power Prediction” que EDP tiene colgado en su web de open data y que incluyo a continuación (Fecha: 2019-11-14). “The objective of this competition is to build an algorithm that predicts the production of solar module B (with optimal orientation) for the first seven days of 2018. For this, you can rely on the weather station data for these days.” Hasta ahora sólo hay 7 participantes, no estoy seguro si hay un score de corte o no, como tienen establecido en otros challenges. El score lo calculan multiplicando el R cuadrado obtenido por 20. Así que ahora mismo las predicciones enviadas han conseguido los siguientes resultados en términos de R cuadrado. ranking &lt;- read_delim(&quot;data/ranking_partipants.csv&quot;, delim = &quot;;&quot;) ranking &lt;- ranking %&gt;% mutate(R2 = Score/20) ranking %&gt;% kable %&gt;% kable_styling() Team Score R2 trevi 19.657 0.98285 Ayrton 19.650 0.98250 Dusan 19.356 0.96780 Pedro Matos 19.192 0.95960 PMAM78 18.900 0.94500 andre 18.855 0.94275 Owls Team 10.968 0.54840 Mi primer objetivo es entrar simplemente en el listado. Así que para intentar asegurar esto tendré que conseguir un R cuadrado superior al conseguido por el “Owls Team”. Lo de conseguir ir más arriba en el ranking de momento no lo veo muy plausible. El resto de R cuadrados los veo realmente muy, muy altos. "],
["modelo-base-.html", "1 Modelo base. 1.1 Datos. 1.2 Importación de tablas de datos 1.3 Modelo base", " 1 Modelo base. 1.1 Datos. 1.2 Importación de tablas de datos # Carga de librerías library(tidyverse) library(data.table) ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last ## The following object is masked from &#39;package:purrr&#39;: ## ## transpose library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:data.table&#39;: ## ## hour, isoweek, mday, minute, month, quarter, second, wday, ## week, yday, year ## The following object is masked from &#39;package:base&#39;: ## ## date library(GGally) ## Registered S3 method overwritten by &#39;GGally&#39;: ## method from ## +.gg ggplot2 ## ## Attaching package: &#39;GGally&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## nasa library(gridExtra) ## ## Attaching package: &#39;gridExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine library(knitr) # Librerías para el modelado library(caret) ## Loading required package: lattice ## ## Attaching package: &#39;caret&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## lift library(ranger) Importo todas las tablas con la información de producción y meteorología. Los datos meteorológicos los separo en dos datasets, el primero del año 2014 al 2017 para el entrenamiento y validación del modelo y el segundo con los datos de 2018 para tomar como datos de entrada para la predicción final. meteo_files &lt;- list.files(path = &quot;data&quot;, pattern = &quot;sunlab-faro-meteo&quot;) data_chr &lt;- rep(&quot;data/&quot;, length(meteo_files)) meteo_files &lt;- paste0(data_chr,meteo_files) meteo_data &lt;- meteo_files %&gt;% map_df(~fread(.)) %&gt;% as_tibble() meteo_data_14_17 &lt;- meteo_data %&gt;% filter(year(Datetime) &lt; 2018) %&gt;% as_tibble() meteo_data_18 &lt;- meteo_data %&gt;% filter(year(Datetime) == 2018) %&gt;% as_tibble() production_files &lt;- list.files(path = &quot;data&quot;, pattern = &quot;sunlab-faro-pv&quot;) data_chr &lt;- rep(&quot;data/&quot;, length(production_files)) production_files &lt;- paste0(data_chr,production_files) production_data &lt;- production_files %&gt;% map_df(~fread(.)) %&gt;% as_tibble() Necesitamos un modelo que prediga la producción del módulo solar B en su orientación óptima. Así que en principio sólo nos tenemos que quedar con la variable B_Optimal - Power DC [W] del dataset “production_data” (también nos quedamos con la variable “Datetime”, que nos permitirá cruzar esta tabla con la que contiene los datos meteorológicos). production_data_optimal_b &lt;- production_data %&gt;% select(Datetime, `B_Optimal - Power DC [W]`) Echamos un vistazo a las variables meteorológicas. summary(meteo_data_14_17) ## Datetime Ambient Temperature [ÂºC] Global Radiation [W/m2] ## Length:1886655 Min. :-1.500e+09 Min. : 0.7285 ## Class :character 1st Qu.: 1.400e+01 1st Qu.: 1.5651 ## Mode :character Median : 1.800e+01 Median : 10.1154 ## Mean :-7.137e+03 Mean : 231.2153 ## 3rd Qu.: 2.300e+01 3rd Qu.: 437.6787 ## Max. : 3.800e+01 Max. :1484.3798 ## ## Diffuse Radiation [W/m2] Ultraviolet [W/m2] Wind Velocity [m/s] ## Min. : 1.6 Min. : 0.4954 Min. :-1.500e+09 ## 1st Qu.: 1.7 1st Qu.: 0.5106 1st Qu.: 1.000e+00 ## Median : 9.9 Median : 1.2513 Median : 2.000e+00 ## Mean : 64.7 Mean :14.1992 Mean :-7.153e+03 ## 3rd Qu.: 98.0 3rd Qu.:25.1983 3rd Qu.: 3.000e+00 ## Max. :776.6 Max. :85.5154 Max. : 1.500e+01 ## NA&#39;s :399744 ## Wind Direction [Âº] Precipitation [mm] Atmospheric pressure [hPa] ## Min. : 0.0 Min. :0 Min. :-1.500e+09 ## 1st Qu.:124.2 1st Qu.:0 1st Qu.: 1.013e+03 ## Median :237.5 Median :0 Median : 1.016e+03 ## Mean :214.2 Mean :0 Mean :-4.106e+03 ## 3rd Qu.:298.3 3rd Qu.:0 3rd Qu.: 1.020e+03 ## Max. :360.0 Max. :2 Max. : 1.036e+03 ## NA&#39;s :1301023 NA&#39;s :1301023 ## Direct Radiation [W/m2] ## Min. : 1.6 ## 1st Qu.: 1.7 ## Median : 8.6 ## Mean : 63.9 ## 3rd Qu.: 91.9 ## Max. :790.1 ## NA&#39;s :1486911 summary(meteo_data_18) ## Datetime Ambient Temperature [ÂºC] Global Radiation [W/m2] ## Length:10079 Min. : 5.100 Min. : 0.9146 ## Class :character 1st Qu.: 9.117 1st Qu.: 1.5885 ## Mode :character Median :11.583 Median : 2.2009 ## Mean :11.764 Mean :106.7527 ## 3rd Qu.:14.500 3rd Qu.:144.7449 ## Max. :19.200 Max. :718.0579 ## ## Diffuse Radiation [W/m2] Ultraviolet [W/m2] Wind Velocity [m/s] ## Min. : 1.597 Min. : 0.4973 Min. :0.000 ## 1st Qu.: 1.659 1st Qu.: 0.5087 1st Qu.:1.683 ## Median : 2.063 Median : 0.5153 Median :2.450 ## Mean : 35.135 Mean : 6.2665 Mean :2.497 ## 3rd Qu.: 59.762 3rd Qu.: 9.4911 3rd Qu.:3.167 ## Max. :368.154 Max. :35.2159 Max. :7.917 ## ## Wind Direction [Âº] Precipitation [mm] Atmospheric pressure [hPa] ## Min. : 0.0 Min. :0.00e+00 Min. :1000 ## 1st Qu.:270.6 1st Qu.:0.00e+00 1st Qu.:1003 ## Median :311.2 Median :0.00e+00 Median :1029 ## Mean :277.9 Mean :9.92e-05 Mean :1020 ## 3rd Qu.:323.2 3rd Qu.:0.00e+00 3rd Qu.:1032 ## Max. :359.8 Max. :1.00e+00 Max. :1035 ## ## Direct Radiation [W/m2] ## Min. : NA ## 1st Qu.: NA ## Median : NA ## Mean :NaN ## 3rd Qu.: NA ## Max. : NA ## NA&#39;s :10079 Y para este modelo cortamos por lo sano y nos quedamos sólo con las variables que no presentan valores nulos en los datos de entrenamiento. meteo_data_14_17_global_rad &lt;- meteo_data_14_17 %&gt;% select(Datetime, `Global Radiation [W/m2]`, `Ambient Temperature [ÂºC]`, `Ultraviolet [W/m2]`, `Wind Velocity [m/s]`, `Wind Direction [Âº]`) 1.3 Modelo base Cruzamos ambos datasets con la ayuda de la variable Datetime. Nos aseguramos de que no haya ningún valor nulo y renombramos las variables. data &lt;- left_join(production_data_optimal_b, meteo_data_14_17_global_rad, by = &quot;Datetime&quot;) %&gt;% na.omit() data &lt;- data %&gt;% rename(global_radiation = `Global Radiation [W/m2]`, power = `B_Optimal - Power DC [W]`, temp = `Ambient Temperature [ÂºC]`, wind_vel = `Wind Velocity [m/s]`, wind_dir = `Wind Direction [Âº]`, ultra_vi = `Ultraviolet [W/m2]`) Echamos un vistazo gráficamente a la relación entre la energía producida y la radiación solar (sólo utilizamos una parte reducida de los datos para que “pinte” el gráfico rápidamente). Y como es de esperar la relación es clara y positiva. set.seed &lt;- 42 sample_data &lt;- sample_n(data, 10000) ggplot(data = sample_data, aes(x = global_radiation, y = power)) + geom_point() Y pasamos a generar el modelo y a evaluarlo. data &lt;- data %&gt;% select(-Datetime) set.seed(42) trainIndex &lt;- createDataPartition(data$power, p = .9, list = FALSE, times = 1) train_data &lt;- data[trainIndex,] validation_data &lt;- data[-trainIndex,] X_validation_data &lt;- validation_data %&gt;% select(-power) y_validation_data &lt;- validation_data %&gt;% select(power) # Generamos un modelo con un random forest de solo 100 árboles con el paquete Ranger. Utilizamos los valores por defecto de todos sus parámetros. rf_mod &lt;- ranger(power ~ ., data = train_data, num.trees = 100, seed = 42) # Generamos una predicción con el modelo generado con los datos de validación prediction &lt;- predict(rf_mod, X_validation_data) y_validation_data &lt;- c(y_validation_data$power) prediction &lt;- c(prediction$predictions) # Y lo evaluamos obteniendo el MAE y el R cuadrado. MAE &lt;- MAE(y_validation_data, prediction) MAE r_squared &lt;- R2(prediction,y_validation_data) r_squared Con este modelo obtenemos un MAE de 15,92 y un R cuadrado de 0,87 [1] 15.92131 [1] 0.8684656 Utilizamos el modelo resultante para generar mi primera predicción. # Generamos el dataset para la predicción pred_data &lt;- meteo_data_18 %&gt;% rename(global_radiation = `Global Radiation [W/m2]`, temp = `Ambient Temperature [ÂºC]`, wind_vel = `Wind Velocity [m/s]`, wind_dir = `Wind Direction [Âº]`, ultra_vi = `Ultraviolet [W/m2]`) %&gt;% arrange(Datetime) %&gt;% select(global_radiation, temp, wind_vel, wind_dir, ultra_vi) prediction &lt;- predict(rf_mod, pred_data) predictions &lt;- prediction$predictions %&gt;% as.data.frame() colnames(predictions) &lt;- &quot;B_Optimal - Power DC [W]&quot; Datetime &lt;- meteo_data_18 %&gt;% select(Datetime) %&gt;% arrange(Datetime) submission_01 &lt;- bind_cols(Datetime, predictions) write_csv(submission_01, &quot;submission_01.csv&quot;) En el primer envío me devolvió un error. El problema es que no hay que enviar las predicciones para todos los registros disponibles de 2018, sino únicamente los que trae el template. Así que generamos de nuevo el csv, pero esta vez cruzandolo con el archivo “Solar_Template.csv”. template &lt;- read_delim(&quot;data/Solar_Template.csv&quot;, delim = &quot;;&quot;) %&gt;% select(Datetime) submission_01 &lt;- read_csv(&quot;submission_01.csv&quot;) submission_02 &lt;- template %&gt;% left_join(submission_01, by = &quot;Datetime&quot;) write_csv(submission_02, &quot;submission_02.csv&quot;) These are the results from my base model for this challenge. I used for this model the features with less number of NAs: Global Radiation [W/m2], Ambient Temperature [ÂºC], Ultraviolet [W/m2], Wind Velocity [m/s] and Wind Direction [Âº]) I applied a random forest of just 100 trees to the data. I used the ranger package on R. rf_mod &lt;- ranger(power ~ ., data = train_data, num.trees = 100, splitrule = “variance”, min.node.size = 5, seed = 42) "]
]
