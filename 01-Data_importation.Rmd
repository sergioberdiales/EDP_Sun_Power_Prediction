# Data importation.

## Data.

## Datasets importation

```{r , warning= FALSE, message= FALSE}
# Carga de librerías
library(tidyverse)
library(dtplyr)
library(data.table)
library(lubridate)
library(GGally)
library(gridExtra)
library(knitr)

# Librerías para el modelado

library(caret)
library(ranger)
```


Importo todas las tablas con la información de producción y meteorología. 
Los datos meteorológicos los separo en dos datasets, el primero del año 2014 al 2017 para el entrenamiento y validación del modelo y el segundo con los datos de 2018 para tomar como datos de entrada para la predicción final.
```{r , message=FALSE}

meteo_files <- list.files(path = "data", pattern = "sunlab-faro-meteo")
data_chr <- rep("data/", length(meteo_files))
meteo_files <- paste0(data_chr,meteo_files)

meteo_data <- meteo_files %>% map_df(~fread(.)) %>% as_tibble()

meteo_data_14_17 <- meteo_data %>% filter(year(Datetime) < 2018) %>% as_tibble()

meteo_data_18 <- meteo_data %>% filter(year(Datetime) == 2018) %>% as_tibble()


production_files <- list.files(path = "data", pattern = "sunlab-faro-pv")
data_chr <- rep("data/", length(production_files))
production_files <- paste0(data_chr,production_files)

production_data <- production_files %>% map_df(~fread(.)) %>% as_tibble()

```

Necesitamos un modelo que prediga la producción del módulo solar B en su orientación óptima. Así que en principio sólo nos tenemos que quedar con la variable `B_Optimal - Power DC [W]` del dataset "production_data" (también nos quedamos con la variable "Datetime", que nos permitirá cruzar esta tabla con la que contiene los datos meteorológicos). 

```{r , message=FALSE}
production_data_optimal_b <- production_data %>% select(Datetime, `B_Optimal - Power DC [W]`)
```

## Modelo base

Como punto de partida vamos a generar un primer modelo muy sencillo. Vamos a intentar explicar la generación de energía basándonos únicamente en los valores de la variable `Global Radiation [W/m2]`. 

Nos quedamos solo con la variable `Global Radiation [W/m2]`
```{r , message=FALSE}
meteo_data_14_17_global_rad <- meteo_data_14_17 %>% select(Datetime, 
                                                           `Global Radiation [W/m2]`,
                                                           `Ambient Temperature [ÂºC]`,
                                                           `Ultraviolet [W/m2]`,
                                                           `Wind Velocity [m/s]`,
                                                           `Wind Direction [Âº]`)                                                  
```


Y cruzamos ambos datasets con la ayuda de la variable Datetime
```{r , message=FALSE}

data <- left_join(production_data_optimal_b, meteo_data_14_17_global_rad, by = "Datetime")  %>% na.omit()

data <- data %>% rename(global_radiation = `Global Radiation [W/m2]`,
                        power = `B_Optimal - Power DC [W]`,
                        temp = `Ambient Temperature [ÂºC]`,
                        wind_vel = `Wind Velocity [m/s]`,
                        wind_dir = `Wind Direction [Âº]`,
                        ultra_vi = `Ultraviolet [W/m2]`)

```



```{r , message=FALSE}
set.seed <- 42
sample_data <- sample_n(data, 10000)
ggplot(data = sample_data, aes(x = global_radiation,  y = power)) +
                        geom_point()
```



```{r , message=FALSE}
set.seed(42)

data <- data %>% select(-Datetime)

trainIndex <- createDataPartition(data$power, p = .9,
                                  list = FALSE,
                                  times = 1)

train_data <- data[trainIndex,] 

validation_data <- data[-trainIndex,] 

X_validation_data <- validation_data %>% select(-power)
y_validation_data <- validation_data %>% select(power)

# We create a base model with all the variables


# Random Forest Model

#tgrid <- expand.grid(
 # .mtry = 2:7,
  #.splitrule = "variance",
  #.min.node.size = c(5, 10, 20)
#)

#model_caret <- train(SalePrice ~ ., data = train_data,
#                     method = "ranger",
#                     trControl = trainControl(method="cv", number = 5, verboseIter = T),
#                     tuneGrid = tgrid,
#                     num.trees = 1000,
#                     importance = "permutation")

#The final values used for the model were mtry = 7, splitrule = variance and min.node.size = 5.

rf_mod <- ranger(power ~ ., 
              data = train_data, 
               num.trees = 10,
                splitrule = "variance",
                min.node.size = 1,
                seed = 42)


prediction <- predict(rf_mod, X_validation_data)

y_validation_data <- c(y_validation_data$power)
prediction <- c(prediction$predictions)

MAE <- MAE(y_validation_data, prediction)
MAE

r_squared <- R2(prediction,y_validation_data)
r_squared

saveRDS(rf_mod, "base_model_rf_1.rds")

```


Con este primer modelo estaríamos explicando un 85,6% de la variabilidad de la energía producida (valor del R cuadrado) con un error absoluto medio (MAE) de 16,72. Creo que con estos resultados me puedo arriesgar para un primer envío. 

Así que hago mi primera predicción 
```{r , message=FALSE}

# Generamos el dataset para la predicción



```

